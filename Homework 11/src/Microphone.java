import java.nio.ByteBuffer;
import java.nio.ShortBuffer;

/**
 * The Microphone class is provided by the microphone manufacturer. 
 * 
 * @author Your friendly CS Professors 
 */
public class Microphone implements Runnable {
	/**
	 * A microphone has some memory for storage, which is audioData, a byte array
	 * When it's memory is full, it must send the data to an AudioConcentrator,
	 * a device that accepts many inputs. (AudioConcentrator is the class you are finishing!)
	 */
	private byte[] audioData;
	
	/**
     * The numberOfSamplesToCollect instructs the microphone how many times you want it to 
     * fill it's buffer of audioData and send it to the AudioConcentrator.
	 */
	private int numberOfSamplesToCollect;
	
	/**
	 * The AudioConcentrator connected to this Microphone.
	 */
	private AudioConcentrator concentrator;


	/** 
	 * A Buffer is a class that provides a data structure for primitive types.
	 * Using these buffers, we can directly write binary data.
	 */
	private ByteBuffer byteBuffer;
	private ShortBuffer shortBuffer;
	private int bytesPerSample;
	private int sampleLength;
	private int sampleSize;
	private double frequency; 

	/**
	 * Constructor.  Instantiates a Microphone with the given AudioConcentrator and
	 * the frequency it should be generating.  Reads the number of audio samples to be
	 * collected from the given AudioConcentrator.
	 * 
	 * @param concentrator The connected AudioConcentrator (i.e., the one that instantiated and started this Microphone)
	 * @param frequency The starting frequency to be generated by this Microphone
	 */
	public Microphone(AudioConcentrator concentrator, double frequency) {
		this.sampleSize = concentrator.getSampleSize();
		audioData = new byte[sampleSize];
		this.numberOfSamplesToCollect = concentrator.getNumberOfSamplesToCollect();
		this.concentrator = concentrator;

		bytesPerSample = 4;
		sampleLength = sampleSize / bytesPerSample;
		byteBuffer = ByteBuffer.wrap(audioData);
		shortBuffer = byteBuffer.asShortBuffer();
		
		// generate a starting frequency 
		this.frequency = frequency;
		System.out.println("Microphone Initialized");
	}

	/**
	 * Run method, the code to execute during the thread.  Sets the Microphone as started with the
	 * AudioConcentrator (by calling startMicrophone), listens to (i.e., generates) the number of audio samples
	 * requested, then sets the microphone as done (by calling endMicrophone().
	 */
	public void run() {
		concentrator.startMicrophone();
		for (int i = numberOfSamplesToCollect; i >0 && !Thread.interrupted(); i--) {
			listen();				
		}
		concentrator.endMicrophone();
	}

	/**
	 * Listen in this context means to record audio data. For this assignment, instead of actually listening to a microphone,
	 * we are generating tones that the microphone is meant to record.
	 */
	public void listen() {
		for (int i = 0; i < sampleLength; i++) {
			// Calculate time-varying gain
			double gain = 16000.0 * i / (sampleSize / bytesPerSample);
			double time = i / 16000.0;
			
			// Generate data for left speaker
			double pianoKeyLeftEar = Math.sin(2 * Math.PI * frequency * time) * Math.exp(-0.0004 * 2 * Math.PI * frequency * time);
			pianoKeyLeftEar = pianoKeyLeftEar*pianoKeyLeftEar*pianoKeyLeftEar;
			shortBuffer.put((short) (gain * pianoKeyLeftEar));

			// generating a chord for the right speaker... just to make an interesting noise
			double pianoKeyRigthEar = Math.sin(2 * Math.PI * frequency*0.99 * time) * Math.exp(-0.0004 * 2 * Math.PI * frequency*0.99 * time);
			pianoKeyRigthEar = pianoKeyRigthEar * pianoKeyRigthEar *pianoKeyRigthEar;
			shortBuffer.put((short) (gain * pianoKeyRigthEar));
		}
		// copy data back to the AudioConcentrator's shared array
		concentrator.storeData(audioData);
		shortBuffer.clear();
	}
}







